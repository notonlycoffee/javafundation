1.线程本身不能独立运行，必须在进程中执行，使用进程的地址空间

2.进程内的同一类线程可以共享代码和数据空间，每个线程有独立的运行栈和程序计数器，切换的开销比较小，灵活性高。

3.java中线程的概念模型：把线程分为三部分：虚拟cpu，虚拟cpu执行的代码和数据

4.使用线程池的理由：
	如果创建过多线程，其中每个线程都将占用一些cpu时间，结果将使用许多内存来支持大量线程，每个线程都运行得很慢，这样无法很好地使用计算机资源
	
5.线程池的方式是：线程目标对象共享线程池中创建的有限的线程对象，比如50个线程目标对象共享两个线程对象

6.newFixedThreadPool(int nThreads)，线程数量的多少是固定的
	6.1如果所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。
	6.2如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务。
	6.3在某个线程被显式关闭之前，池中的线程将一直存在
		
7.defaultThreadFactory()

8.newCachedThreadPool
	8.1线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
	8.2创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
		调用execute将重用以前构造的线程，如果现有线程没有可用的，则创建一个新线程并添加到池中。
		终止并从缓存中移除那些已有60秒未使用的线程。
		
9.newScheduledThreadPool
	创建一个定长线程池，支持定时及周期性任务执行。
	
10.线程的sleep方法调用不会放弃除cpu之外的其他资源

11.线程的终止有三种方法：
	11.1run()方法正常返回
	11.2run()方法意外结束
	11.3应用程序终止

12.中断请求通常是用户希望能够终止线程的执行，但并不会强制终止线程，但是它会中断线程的睡眠状态，比如调用sleep和wait方法之后。

13.线程自己检查中断状态并终止线程比直接调用sotp()方法要安全很多，因为线程可以保存自己的状态，而且stop()已经不推荐使用了

14:和线程中断有关的方法：
	14.1interrupt:向线程发送中断，将中断属性设置为true
	14.2isInterrupted：判断线程是否已经中断，返回中断标志，true或者false
	14.3Interrupted：判断线程是否已经中断，返回中断标志，返回之后将中断标志设置为false
	
15.线程的中断状态只能由线程自己清除，当线程侦测到自己被中断时，经常需要在响应中断之前做某些清除工作，这些清除工作可能涉及那些在线程仍然保持中断状态时会受到影响的操作

16.如果被中断的线程正在执行sleep或者wait方法，就会抛出InterruptedException异常。这种抛出异常的中断会清楚线程的中断状态

17.大体上任何执行阻塞操作的方法，都应该通过Interrupt来取笑阻塞操作。

18.如果希望应用程序在main线程消亡后就退出，就可以把所有创建出来的线程都标记为守护线程。
	我们也可以调用System或者Runtime的exit方法强制应用程序的结束，因为有些类会隐式地创建线程，
	如果创建了非守护线程，那在main线程结束之后，非守护线程还在继续执行，如果还是希望在main线
	程消亡之后就退出，那就需要调用前面说的exit方法退出应用程序来实现了



