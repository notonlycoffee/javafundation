1.类要成为线程安全的，首先必须在单线程环境中有正确的行为

2.一种方法的结果作为另一种方法的输入条件，就是状态依赖,在线程安全中就必须保证至少
	在调用这两种方法期间元素的状态没有改变。一般来说，做到这一点的唯一方法就在调用
	第一个方法之前是独占性地锁定对象，一直到调用了后一种方法以后。

3.五类线程安全性的分类方法：不可变，线程安全，有条件线程安全，线程兼容，线程对立；
	这种分类的核心是调用者是否可以或者必须用外部同步包围操作
		3.1不可变对象：不可变对象一定是线程安全的，并且永远不需要额外的同步，比如Integer，String和BigInteger都是不可变的
		
		3.2线程安全：不管运行环境如何排列，线程都不需要任何额外的同步，这种线程安全性保证是很严格的，很少有类可以实现这样的效果
		
		3.3有条件的线程安全：有条件的线程安全类对于单独的操作是可以线程安全的，但是某些操作序列可能需要外部同步。
			最常见的就是遍历HashTable迭代器的时候修改迭代对象的结构就会抛出concurrentmodifyexception异常
			
		3.4线程兼容：线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。方法是用一个
			synchronized快包围一个方法调用或者创建一个包装器对象。常见的线程兼容类有：ArrayList和HashMap等
			
		3.5线程对立：线程对立类是那些不管是否调用了外部同步都不能在并发使用时安全地呈现的类。线程对立很少见,
			当类修改静态数据，而静态数据会影响在其他线程中执行的其他类的行为，这是通常会出现线程对立

4.	常量始终是线程安全的，因为只存在读操作
	每次调用方法都新建一个实例是线程安全的，因为不会访问共享的资源
	局部变量是线程安全的，因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。
	
5.Servlet中的开发不可以使用成员变量,因为Servlet是多线程访问的时候只会创建一个Servlet类,所以在开发的时候是多个用户访问同一个Servlet上面的
	资源,所有如果有成员变量,就需要使用同步操作.建议最好不要在Servlet中使用成员变量.
	
	
6.把 synchronized 关键字放在类的前面，这个类中的所有方法都是同步方法。

7.在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁
	线程可以获得他已经拥有的锁，运行线程多次获得同一个锁，就是可以重入同步。这种情况通常是同步代码直接或者间接调用也包含了同步代码的方法，
	并且两个代码集都使用同一个锁。如果没有可重入同步，那么，同步代码就必须采取很多额外的预防措施避免线程阻塞自己。
	
8.java提供了一种同步机制，它不提供对锁的独占访问，但同样可以确保对变量的每一个读取操作都返回最近写入的值，这种机制就是只用volatile变量。

9.在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。
	这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 
	一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。
	

