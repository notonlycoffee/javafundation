线程的死锁：
	有两个线程，线程1和线程2；同时有两个资源，资源A和资源B，
	这里线程1占用了资源A，并且需要资源B，
		线程2占用了资源B，并且需要资源A，这样谁也没有放开自己占用的资源，就会出现相互等待的状态，出现死锁
		
		
线程的状态：新建，就绪，运行，阻塞，结束

	新创建一个线程时，它就进入新建状态。调用线程的start()方法启动线程后，它进入就绪状态。
就绪线程是可运行的，但坑农还没有开始运行。操作系统必须为它分配cpu时间

	就绪线程开始运行时，它就进入运行状态。如果给定的cpu时间用完或调用线程的yield()方法，
处于运行状态的线程可能进入就绪状态
	
	有几种原因可能使线程进入阻塞状态(即非活动状态)。可能是它自己调用了join()，
sleep()或wait()方法，也可能是其他线程调用了这些方法。它可能是在等待I/O操作的完成。
当阻塞行为不起阻塞作用时，阻塞线程可能被重新激活。例如，如果线程处于休眠状态并且休眠时间已满，
线程就会重新激活并且进入就绪状态。

	isAlive()方法是用来判断线程状态的方法。如果线程处于就绪，阻塞或运行状态，
则返回true；如果线程处于新建并且没有启动的状态，或者已经结束，就返回false。

	方法interrupt()按下列方式中断一个线程：当线程处于就绪状态或运行状态时，
给它设置一个中断标志；当线程处于阻塞状态时，它将被唤醒并进入就绪状态，同时抛出异常java.lang.InterruptedException.