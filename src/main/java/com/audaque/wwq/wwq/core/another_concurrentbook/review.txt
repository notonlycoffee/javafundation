1.线程本身不能独立运行，必须在进程中执行，使用进程的地址空间

2.进程内的同一类线程可以共享代码和数据空间，每个线程有独立的运行栈和程序计数器，切换的开销比较小，灵活性高。

3.java中线程的概念模型：把线程分为三部分：虚拟cpu，虚拟cpu执行的代码和数据

4.使用线程池的理由：
	如果创建过多线程，其中每个线程都将占用一些cpu时间，结果将使用许多内存来支持大量线程，每个线程都运行得很慢，这样无法很好地使用计算机资源
	
5.线程池的方式是：线程目标对象共享线程池中创建的有限的线程对象，比如50个线程目标对象共享两个线程对象

6.newFixedThreadPool(int nThreads)，线程数量的多少是固定的
	6.1如果所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。
	6.2如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务。
	6.3在某个线程被显式关闭之前，池中的线程将一直存在
		
7.defaultThreadFactory()

8.newCachedThreadPool
	8.1线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
	8.2创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
		调用execute将重用以前构造的线程，如果现有线程没有可用的，则创建一个新线程并添加到池中。
		终止并从缓存中移除那些已有60秒未使用的线程。
		
9.newScheduledThreadPool
	创建一个定长线程池，支持定时及周期性任务执行。
	
10.线程的sleep方法调用不会放弃除cpu之外的其他资源

11.线程的终止有三种方法：
	11.1run()方法正常返回
	11.2run()方法意外结束
	11.3应用程序终止

12.中断请求通常是用户希望能够终止线程的执行，但并不会强制终止线程，但是它会中断线程的睡眠状态，比如调用sleep和wait方法之后。

13.线程自己检查中断状态并终止线程比直接调用sotp()方法要安全很多，因为线程可以保存自己的状态，而且stop()已经不推荐使用了

